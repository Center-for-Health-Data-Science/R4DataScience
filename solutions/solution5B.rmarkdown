---
title: "Exercise 5B - Solutions"
format: html
project:
  type: website
  output-dir: ../docs
---



In lasso regression, the hyperparameter lambda (λ), also known as the L1 penalty, balances the tradeoff between bias and variance in the resulting coefficients. As λ increases, the bias increases, and the variance decreases, leading to a simpler model with fewer parameters.

Finding the Optimal Lambda: The goal is to find the lambda that minimizes the cross-validation error. This corresponds to the point where the model is neither:

Too complex (overfitting) — where the model fits the training data too closely and performs poorly on new, unseen data.

Too simple (underfitting) — where the model is too heavily regularized and doesn't capture the underlying patterns in the data.

1.  Load th R packages needed for analysis:



```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(caret)
library(glmnet)
library(MASS)
```



## Summary Statistics

2.  Load in the dataset `Obt_Perio_ML.Rdata` and inspect it.



```{r}
load(file = "../data/Obt_Perio_ML.Rdata")
```



3.  Do some basic summary statistics and distributional plots to get a feel for the data. Which types of variables do we have?



```{r}

# Reshape data to long format for ggplot2
long_data <- optML %>% 
  dplyr::select(where(is.numeric)) %>%
  pivot_longer(cols = everything(), 
               names_to = "variable", 
               values_to = "value")

# Plot histograms for each numeric variable in one grid
ggplot(long_data, aes(x = value)) +
  geom_histogram(binwidth = 0.5, fill = "#9395D3", color ='grey30') +
  facet_wrap(~ variable, scales = "free") +
  theme_minimal()
```



4.  Make count tables of your categorical/factor variables, are they balanced?



```{r}
# Count observations per level/group for each categorical variable

factor_counts <- optML  %>%
  dplyr::select(where(is.factor)) %>%
  map(~ as.data.frame(table(.))) %>%
  imap(~ setNames(.x, c("Level", "Count")) %>% mutate(Variable = .y)) %>%
  bind_rows() %>%
  relocate(Variable, .before = Level)

factor_counts

```



## Part 1: Elastic Net Regression

5.  As you will use the response `Preg.ended...37.wk`, you should remove the other five outcome measures from your dataset.

6.  Elastic net regression can be sensitive to large differences in the range of numeric/integer variables, as such these variables should be scaled. Scale all numeric/integer variables in your dataset.




```{r}
optML <- optML %>% 
  dplyr::select(-c(Apgar1, Apgar5, GA.at.outcome, Birthweight, Any.SAE.)) %>%
  mutate(across(where(is.numeric), scale))
```



7.  Split your dataset into train and test set, you should have 70% of the data in the training set and 30% in the test set. How you chose to split is up to you, BUT afterwards you should ensure that for the categorical/factor variables all levels are represented in both sets.



```{r}

# Set seed
set.seed(123)

# Training set
train <- optML %>% 
  sample_frac(0.75) 

# Check group levels
train_counts <- train  %>%
  dplyr::select(where(is.factor)) %>%
  map(~ as.data.frame(table(.))) %>%
  imap(~ setNames(.x, c("Level", "Count")) %>% mutate(Variable = .y)) %>%
  bind_rows() %>%
  relocate(Variable, .before = Level)

train_counts




# Training set
test <- optML %>% 
  filter(!PID %in% train$PID)


# Check group levels
#test_counts <- test  %>%
#  dplyr::select(where(is.factor)) %>%
#  map(~ as.data.frame(table(.))) %>%
#  imap(~ setNames(.x, c("Level", "Count")) %>% mutate(Variable = .y)) %>%
#  bind_rows() %>%
#  relocate(Variable, .before = Level)

#test_counts

```



8.  After dividing into train and test set pull out the response variable `Preg.ended...37.wk` into its own vector for both datasets, name these: `y_train` and `y_test`.



```{r}

y_train <- train %>%
  pull(Preg.ended...37.wk)


y_test <- test %>% 
  pull(Preg.ended...37.wk)

```



9.  Remove the response variable `Preg.ended...37.wk` from the train and test set, as well as `PID` (if you have not already done so), as we should obviously not use this for training or testing.



```{r}
train <- train %>% 
  dplyr::select(-c(PID, Preg.ended...37.wk))


test <- test %>% 
  dplyr::select(-c(PID, Preg.ended...37.wk))
```



You will employ the package `glmnet` to perform Elastic Net Regression. The main function from this package is `glmnet()` which we will use to fit the model. Additionally, you will also perform cross validation with `cv.glmnet()` to obtain the best value of the model hyper-parameter, lambda (λ).

As we are working with a mix of categorical and numerical predictors, it is advisable to dummy-code the variables, you can easily do this by creating a model matrix for both test and train set.

10. Create the model matrix needed for input to `glmnet()` and `cv.glmnet()`:



```{r}
modTrain <- model.matrix(~ .- 1, data = train)
modTest <- model.matrix(~ .- 1, data = test)
```



Note that the `- 1` in the `model.matrix()` formula which means, drop the intercept from the matrix.

11. Create your Elastic Net Regression model with `glmnet()`.



```{r}
EN_model <- glmnet(modTrain, y_train, alpha = 1, family = "binomial")
```



12. Use `cv.glmnet()` to attain the best value of the hyperparameter lambda (λ). Remember to set a seed for reproducible results.



```{r}
set.seed(321)
cv_model <- cv.glmnet(modTrain, y_train, alpha = 1, family = "binomial")
```



13. Plot all the values of lambda tested during cross validation by calling `plot()` on the output of your `cv.glmnet()`. Extract the best lambda value from the `cv.glmnet()` model and save it as an object.



```{r}
plot(cv_model)

bestLambda = cv_model$lambda.min
```



Now, lets see how well your model performed.

14. Predict if a individual is likely to give birth before the 37th week using your model and your test set. See pseudo-code below



```{r}
y_pred <- predict(EN_model, s = bestLambda, newx = modTest, type = 'response')
```



15. Just like for the logistic regression model you can calculate the accuracy of the prediction by first converting the predicted probabilities back into class labels (1, 0) and then comparing these to `y_test` with `confusionMatrix()`. Do you have a good accuracy? N.B look at the 2x2 contingency table, what does it tell you?



```{r}
y_pred <- as.factor(ifelse(y_pred > 0.5, 1, 0))

confusionMatrix(y_pred, y_test)
```



16. Lastly, lets extract the variables which were retained in the model (e.g. not penalized out). We do this by calling the coefficient with `coef()` on our model. See pseudo-code below.



```{r}
coeffs <- coef(EN_model, s = bestLambda)

# Convert coefficients to a data frame for easier viewing
coeffsDat <- as.data.frame(as.matrix(coeffs)) %>% 
  rownames_to_column(var = 'VarName')
 
```



16. Make a plot that shows the absolute importance of the variables retained in your model. This could be barplot with variable names on the x-axis and the height of the bars denoting absolute size of coefficient).



```{r}

# Make dataframe ready for plotting, remove intercept and coeffcients that are zero
coeffsDat <- coeffsDat %>% 
  mutate(AbsImp = abs(s1)) %>%
  arrange(AbsImp) %>%
  mutate(VarName = factor(VarName, levels=VarName)) %>%
  filter(AbsImp > 0 & VarName != "(Intercept)")


# Plot
ggplot(coeffsDat, aes(x = VarName, y = AbsImp)) +
  geom_bar(stat = "identity", fill = "#9395D3") +
  coord_flip() +
  labs(title = "Feature Importance for Elastic Net", 
       x = "Features", 
       y = "Absolute Coefficients") +
  theme_classic()
```



17. Make a logistic regression using this dataset (you already have your train data, test data, y_train and y_test). Do you get similar results?

